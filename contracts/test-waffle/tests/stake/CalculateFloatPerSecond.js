// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Chai = require("../../bindings/chai/Chai.js");
var LetOps = require("../../library/LetOps.js");
var Globals = require("../../library/Globals.js");
var Helpers = require("../../library/Helpers.js");
var CONSTANTS = require("../../CONSTANTS.js");
var StakerHelpers = require("./StakerHelpers.js");
var StakerSmocked = require("../../library/smock/StakerSmocked.js");

function getRequiredAmountOfBitShiftForSafeExponentiation(number, exponent) {
  var amountOfBitShiftRequired = Globals.bnFromInt(0);
  var targetMaxNumberSizeBinaryDigits = Globals.div(Globals.bnFromInt(256), exponent);
  var targetMaxNumber = Globals.pow(Globals.twoBn, targetMaxNumberSizeBinaryDigits);
  while(Globals.bnGt(Globals.div(number, Globals.pow(Globals.twoBn, amountOfBitShiftRequired)), targetMaxNumber)) {
    amountOfBitShiftRequired = Globals.add(amountOfBitShiftRequired, Globals.oneBn);
  };
  return amountOfBitShiftRequired;
}

function test(contracts, accounts) {
  var match = Helpers.Tuple.make5(Helpers.randomTokenAmount);
  var randomValueLocked2 = match[4];
  var randomValueLocked1 = match[3];
  var shortPrice = match[2];
  var longPrice = match[1];
  var kVal = match[0];
  describe("calculateFloatPerSecond", (function () {
          var calculateFloatPerSecondPerPaymentTokenLocked = function (underBalancedSideValue, exponent, equilibriumOffsetMarket, totalLocked, requiredBitShifting) {
            var overflowProtectionDivision = Globals.pow(Globals.twoBn, requiredBitShifting);
            var numerator = Globals.pow(Globals.div(Globals.sub(underBalancedSideValue, equilibriumOffsetMarket), Globals.div(overflowProtectionDivision, Globals.twoBn)), exponent);
            var denominator = Globals.div(Globals.pow(Globals.div(totalLocked, overflowProtectionDivision), exponent), Globals.tenToThe18);
            var overBalancedSideRate = Globals.div(Globals.div(numerator, denominator), Globals.twoBn);
            var underBalancedSideRate = Globals.sub(Globals.tenToThe18, overBalancedSideRate);
            Chai.expectTrue(Globals.bnGte(underBalancedSideRate, overBalancedSideRate));
            return [
                    overBalancedSideRate,
                    underBalancedSideRate
                  ];
          };
          var balanceIncentiveCurve_exponent = {
            contents: undefined
          };
          beforeEach(function () {
                return LetOps.Await.let_(StakerHelpers.deployAndSetupStakerToUnitTest("_calculateFloatPerSecond", contracts, accounts), (function (param) {
                              return LetOps.Await.let_(contracts.contents.staker.balanceIncentiveCurve_exponent(1), (function (balanceIncentiveCurve_exponentFetched) {
                                            balanceIncentiveCurve_exponent.contents = balanceIncentiveCurve_exponentFetched;
                                            return StakerSmocked.InternalMock.mock_getKValueToReturn(kVal);
                                          }));
                            }));
              });
          var testHelper = function (longPrice, shortPrice, longValue, shortValue) {
            var totalLocked = Globals.add(longValue, shortValue);
            var requiredBitShifting = Globals.bnFromInt(52);
            return LetOps.Await.let_(contracts.contents.staker._calculateFloatPerSecondExposed(1, longPrice, shortPrice, longValue, shortValue), (function (result) {
                          var longFloatPerSecond = result.longFloatPerSecond;
                          var shortFloatPerSecond = result.shortFloatPerSecond;
                          if (Globals.bnGte(longValue, shortValue)) {
                            var match = calculateFloatPerSecondPerPaymentTokenLocked(shortValue, balanceIncentiveCurve_exponent.contents, CONSTANTS.zeroBn, totalLocked, requiredBitShifting);
                            var longRateScaled = Globals.div(Globals.mul(Globals.mul(match[0], kVal), longPrice), Globals.tenToThe18);
                            var shortRateScaled = Globals.div(Globals.mul(Globals.mul(match[1], kVal), shortPrice), Globals.tenToThe18);
                            Chai.bnEqual(undefined, longFloatPerSecond, longRateScaled);
                            return Chai.bnEqual(undefined, shortFloatPerSecond, shortRateScaled);
                          }
                          var match$1 = calculateFloatPerSecondPerPaymentTokenLocked(longValue, balanceIncentiveCurve_exponent.contents, CONSTANTS.zeroBn, totalLocked, requiredBitShifting);
                          var longRateScaled$1 = Globals.div(Globals.mul(Globals.mul(match$1[1], kVal), longPrice), Globals.tenToThe18);
                          var shortRateScaled$1 = Globals.div(Globals.mul(Globals.mul(match$1[0], kVal), shortPrice), Globals.tenToThe18);
                          Chai.bnEqual(undefined, longFloatPerSecond, longRateScaled$1);
                          return Chai.bnEqual(undefined, shortFloatPerSecond, shortRateScaled$1);
                        }));
          };
          describe("returns correct longFloatPerSecond and shortFloatPerSecond for each market side and calls getKValue correctly", (function () {
                  it("longValue > shortValue", (function () {
                          return LetOps.Await.let_(testHelper(longPrice, shortPrice, Globals.add(randomValueLocked1, randomValueLocked2), randomValueLocked2), (function (param) {
                                        
                                      }));
                        }));
                  it("longValue < shortValue", (function () {
                          return LetOps.Await.let_(testHelper(longPrice, shortPrice, randomValueLocked1, Globals.add(randomValueLocked1, randomValueLocked2)), (function (param) {
                                        
                                      }));
                        }));
                  
                }));
          it("calls getKValue correctly", (function () {
                  StakerSmocked.InternalMock.mock_getKValueToReturn(kVal);
                  return LetOps.Await.let_(contracts.contents.staker._calculateFloatPerSecondExposed(1, longPrice, shortPrice, randomValueLocked1, randomValueLocked2), (function (_result) {
                                var call = StakerSmocked.InternalMock._getKValueCalls(undefined)[0];
                                return Chai.recordEqualFlat(call, {
                                            marketIndex: 1
                                          });
                              }));
                }));
          it("reverts for empty markets", (function () {
                  return Chai.expectRevertNoReason(contracts.contents.staker._calculateFloatPerSecondExposed(1, CONSTANTS.zeroBn, CONSTANTS.zeroBn, CONSTANTS.zeroBn, CONSTANTS.zeroBn));
                }));
          
        }));
  
}

exports.getRequiredAmountOfBitShiftForSafeExponentiation = getRequiredAmountOfBitShiftForSafeExponentiation;
exports.test = test;
/* Chai Not a pure module */
